<script>
  // ==== Crypto helpers (AES-GCM, base64url) ====
  function b64urlEncode(bytes) {
    let str = "";
    const arr = new Uint8Array(bytes);
    for (let i = 0; i < arr.length; i++) {
      str += String.fromCharCode(arr[i]);
    }
    return btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  function b64urlDecode(str) {
    str = str.replace(/-/g, "+").replace(/_/g, "/");
    const pad = str.length % 4;
    if (pad) str += "====".slice(pad);
    const bin = atob(str);
    const bytes = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) {
      bytes[i] = bin.charCodeAt(i);
    }
    return bytes;
  }

  async function encryptText(key, text) {
    const enc = new TextEncoder();
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const cipherBuf = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      enc.encode(text)
    );
    return {
      cipherB64: b64urlEncode(cipherBuf),
      ivB64: b64urlEncode(iv)
    };
  }

  async function decryptText(key, cipherB64, ivB64) {
    const dec = new TextDecoder();
    const iv = b64urlDecode(ivB64);
    const cipherBytes = b64urlDecode(cipherB64);

    const plainBuf = await crypto.subtle.decrypt(
      { name: "AES-GCM", iv },
      key,
      cipherBytes
    );
    return dec.decode(plainBuf);
  }

  async function generateThreadKey() {
    const keyBytes = crypto.getRandomValues(new Uint8Array(32));
    const key = await crypto.subtle.importKey(
      "raw",
      keyBytes,
      { name: "AES-GCM" },
      false,
      ["encrypt", "decrypt"]
    );
    const keyB64 = b64urlEncode(keyBytes);
    return { key, keyB64 };
  }

  async function importThreadKey(keyB64) {
    const raw = b64urlDecode(keyB64);
    return crypto.subtle.importKey(
      "raw",
      raw,
      { name: "AES-GCM" },
      false,
      ["encrypt", "decrypt"]
    );
  }

  // ==== State ====
  let threadToken = null;
  let threadKey = null;
  let threadKeyB64 = null;
  let lastMessageIds = new Set();
  let mySentSignatures = new Set(); // cipher|iv pro moje zpr√°vy
  let expiresAt = null;
  let countdownTimer = null;
  let lastActivity = Date.now();

  const chatWindow = document.getElementById("chatWindow");
  const chatInput = document.getElementById("chatInput");
  const chatSendBtn = document.getElementById("chatSendBtn");
  const createThreadBtn = document.getElementById("createThreadBtn");
  const threadInfo = document.getElementById("threadInfo");
  const threadStatus = document.getElementById("threadStatus");
  const countdownEl = document.getElementById("countdown");

  const shadowCard = document.getElementById("shadowCard");
  const shadowTitle = document.getElementById("shadowTitle");
  const shadowStateLabel = document.getElementById("shadowStateLabel");
  const shadowLangToggle = document.getElementById("shadowLangToggle");
  const shadowLog = document.getElementById("shadowLog");

  let shadowLang = "cs"; // "cs" nebo "en"
  let angelMode = false;
  let angelTimeout = null;

  const shadowConfig = {
    idleFirst: 60000,
    idleSecond: 180000,
    heckleEveryMin: 45000,
    lastIdleNoticed: 0
  };

  const shadowPositions = [
    { bottom: "18px", right: "18px", top: "auto", left: "auto" },
    { bottom: "18px", left: "18px", top: "auto", right: "auto" },
    { top: "18px", left: "18px", bottom: "auto", right: "auto" },
    { top: "18px", right: "18px", bottom: "auto", left: "auto" }
  ];
  let currentShadowPosIndex = 0;
  let teleportChain = 0;

  const emojiTriggers = [":)", ":-)", ":D", "üòÇ", "üôÇ", "üòÖ", "üòâ"];
  const swearTriggers = ["fuck", "shit", "kurva", "p√≠ƒça", "kokot", "do prdele"];
  const lolTriggers = ["lol", "lmao", "xd", "xD", "wtf"];
  const helpTriggers = ["help", "pomoc", "help me", "nev√≠m", "nevim"];
  const secretTriggers = ["secret", "tajn√Ω", "tajne", "tajn√Ω", "hidden"];

  const shadowTexts = {
    cs: {
      idle: [
        "zase ticho ¬∑ vl√°kno po≈ô√°d ≈æije, ty u≈æ m√©nƒõ.",
        "minuta nic ¬∑ docela drah√Ω timer na kouk√°n√≠.",
        "burn lane nen√≠ screensaver, v√≠≈° o tom?"
      ],
      longIdle: [
        "3 minuty ticha ¬∑ to u≈æ je skoro meditace, ne chat.",
        "jestli tohle je tv≈Øj komunikaƒçn√≠ styl, ch√°pu p√°r ex.",
        "thread ƒçek√°, ty scrolluje≈° jinde. klasika."
      ],
      send: [
        "no koneƒçnƒõ nƒõjak√Ω sign√°l.",
        "text vypu≈°tƒõn ¬∑ karma si ho p≈ôebere.",
        "posl√°no ¬∑ jen doufej, ≈æe to st√°lo za klik."
      ],
      spawn: [
        "nov√© vl√°kno ¬∑ jen ƒças uk√°≈æe, jestli zbyteƒçnƒõ.",
        "thread ready ¬∑ timer bƒõ≈æ√≠, ty teprve p≈ôem√Ω≈°l√≠≈°.",
        "nov√° lane ¬∑ doufej, ≈æe bude≈° zaj√≠mavƒõj≈°√≠ ne≈æ poslednƒõ."
      ],
      nearEnd: [
        "ƒças doho≈ô√≠v√° ¬∑ jestli nƒõco schov√°v√°≈°, tak rychle.",
        "TTL skoro nula ¬∑ tv√° obl√≠ben√° discipl√≠na: odkl√°d√°n√≠.",
        "za chv√≠li tma ¬∑ jestli m√°≈° co ≈ô√≠ct, tak teƒè."
      ],
      random: [
        "v√≠c maƒçk√°≈° Backspace ne≈æ Send. pozn√°m typ.",
        "u≈æ teƒè v√≠m, ≈æe tohle vl√°kno skonƒç√≠ divnƒõ.",
        "nƒõkdo chod√≠ ven, ty si pov√≠d√°≈° s konzol√≠. respekt.",
        "jestli to screenshotuje≈°, tot√°lnƒõ m√≠j√≠≈° pointu.",
        "po≈ô√°d lep≈°√≠ ps√°t sem ne≈æ ex na IG.",
        "ty znaky u≈æ ti nikdo nevr√°t√≠. dobr√Ω trade."
      ],
      emoji: [
        "smajl√≠k jo? to je tvoje bezpeƒçn√© slovo.",
        "aha, emoce. syst√©m si je zap√≠≈°e do slo≈æky 'podez≈ôel√©'.",
        "emoji detected ¬∑ lidskost potvrzena, stabilita nejist√°."
      ],
      swear: [
        "nad√°vky u≈æ m√°me, teƒè je≈°tƒõ obsah.",
        "klasika. do vl√°kna se nad√°v√°, do sebe se ne≈°ah√°.",
        "ƒç√≠m v√≠c sprost√Ωch slov, t√≠m m√©nƒõ konkr√©tn√≠ch pl√°n≈Ø."
      ],
      lol: [
        "lol je prostƒõ modern√≠ 'nev√≠m co ≈ô√≠ct'.",
        "kdy≈æ nev√≠≈°, napi≈° lol. funguje od roku 2008.",
        "XD detected ¬∑ archiv to p≈ôe≈æije, ty snad taky."
      ],
      helpAngelIntro: [
        "jo, tak ty bys chtƒõl pomoc‚Ä¶ v√Ωjimeƒçnƒõ to vezmeme v√°≈ænƒõ.",
        "dob≈ôe, pauza od ≈°≈•ouch√°n√≠. na chv√≠li.",
        "fajn. zap√≠n√°m 'hodnej re≈æim'. ne≈ô√≠kej to nikomu."
      ],
      helpAngelAdvice: [
        "z√°klad: pi≈° konkr√©tnƒõ, kr√°tce, jednu vƒõc po druh√©. vl√°kno je kr√°tk√Ω, ne ≈æivot.",
        "nejvƒõt≈°√≠ chyba? ps√°t vƒõci jen v hlavƒõ. sem s nimi, tohle m√≠sto je na rozbit√≠ my≈°lenek.",
        "jestli v√°h√°≈°, co napsat, napi≈° 'co fakt nechci, aby se stalo'. zbytek z toho vyleze."
      ],
      helpAngelOutro: [
        "dobro u≈æ bylo, jdu zase dƒõlat srandu.",
        "andƒõl√≠ƒçek vypnut√Ω. zp√°tky do chaosu.",
        "tohle byl bonus. dal≈°√≠ rady za nad√°vky a kafe."
      ],
      consoleReply: [
        "jojo, jasnƒõ, zap√≠≈°u si to do imagin√°rn√≠ho backlogu.",
        "zaj√≠mav√Ω input. ≈°koda, ≈æe ti za to nikdo neplat√≠.",
        "noted. syst√©m to mo≈æn√° pou≈æije proti tobƒõ.",
        "m√°≈° pocit, ≈æe ti odpov√≠d√°m m√°lo? v√≠tej v realitƒõ."
      ]
    },
    en: {
      idle: [
        "one minute of silence ¬∑ impressive commitment to doing nothing.",
        "idle again ¬∑ this thread has more patience than your ex.",
        "you opened a burn lane just to stare at it. iconic."
      ],
      longIdle: [
        "3 minutes of silence ¬∑ this is no longer a chat, it's a museum.",
        "thread alive, user brain on standby. good combo.",
        "you're treating this like a diary you never write in."
      ],
      send: [
        "finally, a neuron fired.",
        "message launched ¬∑ consequences pending.",
        "you pressed send ¬∑ bold move for a Tuesday."
      ],
      spawn: [
        "new thread spawned ¬∑ let's see how fast you waste it.",
        "fresh lane online ¬∑ you already look suspicious.",
        "thread ready ¬∑ your overthinking starts now."
      ],
      nearEnd: [
        "TTL almost zero ¬∑ like your attention span.",
        "clock redlining ¬∑ say something or let it die.",
        "this thread is fading faster than your motivation."
      ],
      random: [
        "you‚Äôre talking to a floating console instead of a human. solid priorities.",
        "if overthinking was a currency, you‚Äôd own this app.",
        "some people meditate, you open encrypted threads. fair.",
        "if you're screenshotting this, you missed the point.",
        "you deleted more drafts than you sent. relatable.",
        "this is either genius or a cry for help. hard to tell."
      ],
      emoji: [
        "emoji, huh? emotional damage but make it cute.",
        "you dropped a smiley in an ephemeral thread. brave.",
        "emoji detected ¬∑ humanity confirmed, stability questionable."
      ],
      swear: [
        "swearing helps, but planning helps more.",
        "nice vocabulary. now try using it on your problems.",
        "rage detected ¬∑ output still underwhelming."
      ],
      lol: [
        "lol is just 'i have nothing of value to add'.",
        "XD detected ¬∑ internet trauma level: stable.",
        "you typed 'lol' instead of feelings. understandable."
      ],
      helpAngelIntro: [
        "So you want help? Fine. Briefly.",
        "Okay, pause on bullying you. For a moment.",
        "Turning on 'pretend to care' mode‚Ä¶ just this once."
      ],
      helpAngelAdvice: [
        "Write one concrete thing per message. No essays, no novels. Just what hurts and what you want to move.",
        "Start with: 'I don't want X to happen.' Your brain is much better at spotting danger than goals.",
        "Don't chase perfect wording. Chase the next honest sentence. The burn takes care of the rest."
      ],
      helpAngelOutro: [
        "Angel mode off. Back to feral.",
        "That‚Äôs enough kindness for today.",
        "You got real advice. Don't waste it."
      ],
      consoleReply: [
        "Sure. I‚Äôll file that under 'emotional noise with potential'.",
        "Noted. If I had eyebrows, I'd raise one.",
        "Message received. Judgment pending.",
        "Cool. Now do something with it offline too."
      ]
    }
  };

  function bumpActivity() {
    lastActivity = Date.now();
  }

  function pick(arr) {
    return arr[Math.floor(Math.random() * arr.length)];
  }

  function applyShadowPos(index) {
    if (!shadowCard) return;
    const pos = shadowPositions[index];
    shadowCard.style.bottom = pos.bottom;
    shadowCard.style.top = pos.top;
    shadowCard.style.left = pos.left;
    shadowCard.style.right = pos.right;
  }

  function teleportShadow() {
    if (!shadowCard) return;
    let next = currentShadowPosIndex;
    while (next === currentShadowPosIndex) {
      next = Math.floor(Math.random() * shadowPositions.length);
    }
    currentShadowPosIndex = next;
    applyShadowPos(next);
    shadowCard.classList.add("glitch");
    setTimeout(() => shadowCard.classList.remove("glitch"), 200);
  }

  function maybeTeleport() {
    if (!shadowCard) return;
    if (Math.random() < 0.4 || teleportChain > 0) {
      teleportShadow();
      teleportChain++;
      if (teleportChain >= 3) teleportChain = 0;
    }
  }

  function emojiRain() {
    if (!shadowLog) return;
    const layer = document.createElement("div");
    layer.className = "emoji-rain-layer";
    const emojis = ["üòÇ", "üôÇ", "üòÖ", "üòâ", "ü§°"];
    const drops = 14;
    for (let i = 0; i < drops; i++) {
      const span = document.createElement("span");
      span.className = "emoji-drop";
      span.textContent = pick(emojis);
      span.style.left = Math.random() * 100 + "%";
      span.style.animationDelay = (Math.random() * 0.6) + "s";
      layer.appendChild(span);
    }
    shadowLog.appendChild(layer);
    setTimeout(() => {
      layer.remove();
    }, 1600);
  }

  function textHasAnyTrigger(text, arr) {
    const lower = text.toLowerCase();
    return arr.some(w => lower.includes(w));
  }

  function textHasEmojiTrigger(text) {
    return textHasAnyTrigger(text, emojiTriggers);
  }

  function spawnShadowGhost() {
    // kr√°tk√Ω ghost konzole nƒõkde jinde
    const ghost = document.createElement("div");
    ghost.className = "card shadow-card";
    ghost.style.transform = "scale(0.85)";
    const pos = shadowPositions[Math.floor(Math.random() * shadowPositions.length)];
    ghost.style.bottom = pos.bottom;
    ghost.style.top = pos.top;
    ghost.style.left = pos.left;
    ghost.style.right = pos.right;
    ghost.style.opacity = "0.85";

    const inner = document.createElement("div");
    inner.style.padding = "8px 10px";
    inner.style.fontSize = "0.76rem";
    inner.style.color = "#c5c0f0";
    inner.innerHTML = `
      <div class="shadow-line"><span>[ghost]</span> desync copy spawned.</div>
      <div class="shadow-line"><span>[ghost]</span> don't worry, you're not supposed to understand this.</div>
    `;
    ghost.appendChild(inner);
    document.body.appendChild(ghost);

    setTimeout(() => {
      ghost.classList.add("hidden");
      setTimeout(() => ghost.remove(), 400);
    }, 2600);
  }

  function logShadow(rawText) {
    if (!shadowLog) return;
    const line = document.createElement("div");
    line.className = "shadow-line";
    const ts = new Date().toLocaleTimeString("cs-CZ", { hour: "2-digit", minute: "2-digit" });
    line.innerHTML = `<span>[${ts}]</span> ${rawText}`;
    shadowLog.appendChild(line);
    shadowLog.scrollTop = shadowLog.scrollHeight;

    if (Math.random() < 0.25 && shadowCard) {
      shadowCard.classList.add("glitch");
      setTimeout(() => shadowCard.classList.remove("glitch"), 200);
    }

    showShadow(true);

    // obƒças i ghost split
    if (Math.random() < 0.1) {
      spawnShadowGhost();
    }
  }

  function setThreadInfo(text) {
    threadInfo.textContent = text;
  }

  function updateCountdown() {
    if (!expiresAt) {
      countdownEl.textContent = "";
      return;
    }
    const now = new Date();
    const diffMs = new Date(expiresAt) - now;
    if (diffMs <= 0) {
      countdownEl.textContent = "Vl√°kno vypr≈°elo.";
      chatInput.disabled = true;
      chatSendBtn.disabled = true;
      return;
    }
    const minutes = Math.floor(diffMs / 60000);
    const seconds = Math.floor((diffMs % 60000) / 1000);
    countdownEl.textContent = `TTL: ${minutes}m ${seconds}s`;
    if (minutes === 0 && seconds < 30 && Math.random() < 0.2) {
      const txt = pick(shadowTexts[shadowLang].nearEnd);
      logShadow(txt);
    }
  }

  function startCountdown() {
    if (countdownTimer) clearInterval(countdownTimer);
    updateCountdown();
    countdownTimer = setInterval(updateCountdown, 1000);
  }

  function renderMessageBubble(id, createdAt, text, isMe) {
    if (lastMessageIds.has(id)) return;
    lastMessageIds.add(id);

    const wrap = document.createElement("div");
    wrap.className = "bubble " + (isMe ? "me" : "other");
    const p = document.createElement("div");
    p.textContent = text;
    const meta = document.createElement("div");
    meta.className = "bubble-meta";
    const t = new Date(createdAt);
    meta.textContent = t.toLocaleTimeString("cs-CZ", { hour: "2-digit", minute: "2-digit" });

    wrap.appendChild(p);
    wrap.appendChild(meta);
    chatWindow.appendChild(wrap);
    chatWindow.scrollTop = chatWindow.scrollHeight;
  }

  async function loadThread() {
    if (!threadToken || !threadKey) return;
    try {
      const res = await fetch("/.netlify/functions/thread-load", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ token: threadToken })
      });

      if (res.status === 410) {
        const data = await res.json().catch(() => null);
        setThreadInfo("Vl√°kno je expirovan√© nebo zav≈ôen√©.");
        logShadow(shadowLang === "cs"
          ? "thread mrtv√Ω ¬∑ zbyly jen logy."
          : "thread is dead ¬∑ only logs remain.");
        chatInput.disabled = true;
        chatSendBtn.disabled = true;
        if (data && data.expires_at) {
          expiresAt = data.expires_at;
          updateCountdown();
        }
        return;
      }

      if (!res.ok) {
        setThreadInfo("Server odpovƒõdƒõl divnƒõ. Zkus reload.");
        logShadow(shadowLang === "cs"
          ? "backend mluv√≠ v jazyce chyb. zkus to pozdƒõji."
          : "backend answered in errors. try again later.");
        return;
      }

      const data = await res.json();
      if (!data.ok) return;

      expiresAt = data.thread.expires_at;
      startCountdown();

      const messages = data.messages || [];
      for (const msg of messages) {
        try {
          const plain = await decryptText(threadKey, msg.cipher, msg.iv);
          const sig = msg.cipher + "|" + msg.iv;
          const isMe = mySentSignatures.has(sig);
          renderMessageBubble(msg.id, msg.created_at, plain, isMe);
        } catch {
          // ignore decrypt errors
        }
      }
    } catch (e) {
      console.error("loadThread error", e);
      logShadow(shadowLang === "cs"
        ? "nƒõco se rozpadlo mezi n√°mi a DB."
        : "something broke between us and the DB.");
    }
  }

  function handleSpecialTriggers(text) {
    const lower = text.toLowerCase();

    if (textHasAnyTrigger(lower, helpTriggers)) {
      // angel m√≥d
      if (!angelMode) {
        angelMode = true;
        if (shadowCard) shadowCard.classList.add("angel");
        logShadow(pick(shadowTexts[shadowLang].helpAngelIntro));
        logShadow(pick(shadowTexts[shadowLang].helpAngelAdvice));
        if (angelTimeout) clearTimeout(angelTimeout);
        angelTimeout = setTimeout(() => {
          logShadow(pick(shadowTexts[shadowLang].helpAngelOutro));
          angelMode = false;
          if (shadowCard) shadowCard.classList.remove("angel");
        }, 8000);
      }
      return true;
    }

    if (textHasAnyTrigger(lower, swearTriggers)) {
      logShadow(pick(shadowTexts[shadowLang].swear));
      return true;
    }

    if (textHasAnyTrigger(lower, lolTriggers)) {
      logShadow(pick(shadowTexts[shadowLang].lol));
      return true;
    }

    if (textHasAnyTrigger(lower, secretTriggers)) {
      const line = shadowLang === "cs"
        ? "tajemstv√≠ v burn lane‚Ä¶ tohle nekonƒç√≠ dob≈ôe ani ve filmech."
        : "secrets in a burn lane‚Ä¶ what could possibly go wrong.";
      logShadow(line);
      return true;
    }

    return false;
  }

  async function sendMessage() {
    if (!threadToken || !threadKey) {
      threadStatus.textContent = "Nejd≈ô√≠v vytvo≈ô nebo naƒçti vl√°kno.";
      logShadow(shadowLang === "cs"
        ? "nejd≈ô√≠v vl√°kno, pak drama."
        : "thread first, drama after.");
      return;
    }
    const text = (chatInput.value || "").trim();
    if (!text) return;
    chatInput.value = "";
    bumpActivity();

    try {
      const { cipherB64, ivB64 } = await encryptText(threadKey, text);
      const signature = cipherB64 + "|" + ivB64;
      mySentSignatures.add(signature);

      const res = await fetch("/.netlify/functions/thread-post", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          token: threadToken,
          cipher: cipherB64,
          iv: ivB64
        })
      });

      if (res.status === 410) {
        setThreadInfo("Vl√°kno vypr≈°elo. Tuhle zpr√°vu u≈æ nevlo≈æ√≠me.");
        logShadow(shadowLang === "cs"
          ? "zkou≈°√≠≈° mluvit na mrtv√© vl√°kno. cute."
          : "trying to talk to a dead thread. adorable.");
        chatInput.disabled = true;
        chatSendBtn.disabled = true;
        return;
      }

      if (!res.ok) {
        threadStatus.textContent = "Server odm√≠tl zpr√°vu. Zkus to znovu.";
        logShadow(shadowLang === "cs"
          ? "server ≈ôekl ne. zkus to znova."
          : "server said no. try again.");
        return;
      }

      const handled = handleSpecialTriggers(text);

      if (!handled) {
        if (textHasEmojiTrigger(text)) {
          const txt = pick(shadowTexts[shadowLang].emoji);
          logShadow(txt);
          emojiRain();
        } else {
          const txt = pick(shadowTexts[shadowLang].send);
          logShadow(txt);
        }
      }

      await loadThread();
    } catch (e) {
      console.error("sendMessage error", e);
      logShadow(shadowLang === "cs"
        ? "posl√°n√≠ selhalo ¬∑ linka p≈ôest≈ôi≈æen√°."
        : "send failed ¬∑ line cut.");
    }
  }

  async function createThread() {
    try {
      const res = await fetch("/.netlify/functions/thread-create", {
        method: "POST"
      });
      if (!res.ok) {
        setThreadInfo("Server odm√≠tl vytvo≈ôit vl√°kno.");
        logShadow(shadowLang === "cs"
          ? "thread spawn fail ¬∑ backend trucuje."
          : "thread spawn failed ¬∑ backend sulking.");
        return;
      }
      const data = await res.json();
      if (!data.ok) {
        setThreadInfo("Vytvo≈ôen√≠ vl√°kna selhalo.");
        logShadow(shadowLang === "cs"
          ? "thread spawn vr√°til blbosti."
          : "thread spawn returned nonsense.");
        return;
      }

      threadToken = data.token;
      expiresAt = data.expires_at;
      mySentSignatures = new Set();
      lastMessageIds = new Set();
      chatWindow.innerHTML = "";
      bumpActivity();

      const { key, keyB64 } = await generateThreadKey();
      threadKey = key;
      threadKeyB64 = keyB64;

      const url = new URL(window.location.href);
      url.searchParams.set("t", threadToken);
      url.hash = "#" + keyB64;
      history.replaceState(null, "", url.toString());

      setThreadInfo("Vl√°kno vytvo≈ôen√©. Link sd√≠lej cel√Ω (vƒçetnƒõ #...).");
      logShadow(pick(shadowTexts[shadowLang].spawn));
      startCountdown();
      chatInput.disabled = false;
      chatSendBtn.disabled = false;

    } catch (e) {
      console.error("createThread error", e);
      setThreadInfo("Nƒõco se pokazilo p≈ôi vytv√°≈ôen√≠ vl√°kna.");
      logShadow(shadowLang === "cs"
        ? "thread spawn exception ¬∑ realita se zadrhla."
        : "thread spawn exception ¬∑ reality glitched.");
    }
  }

  async function initFromUrl() {
    const url = new URL(window.location.href);
    const token = url.searchParams.get("t");
    const hash = window.location.hash || "";
    const keyStr = hash.startsWith("#") ? hash.slice(1) : "";

    if (!token && !keyStr) {
      setThreadInfo("≈Ω√°dn√© vl√°kno. Klikni na Start new thread.");
      logShadow(shadowLang === "cs"
        ? "bez threadu tu jen stoj√≠≈° v pr√°zdnu."
        : "no thread ¬∑ just you and the void.");
      chatInput.disabled = true;
      chatSendBtn.disabled = true;
      return;
    }

    if (token && !keyStr) {
      setThreadInfo("Vl√°kno m√° token, ale chyb√≠ ≈°ifrovac√≠ kl√≠ƒç (#...). Bez nƒõj neƒçteme.");
      logShadow(shadowLang === "cs"
        ? "thread token bez kl√≠ƒçe ¬∑ p≈Øl linku, p≈Øl vtip."
        : "thread token without key ¬∑ half link, half joke.");
      chatInput.disabled = true;
      chatSendBtn.disabled = true;
      return;
    }

    if (!token && keyStr) {
      setThreadInfo("M√°≈° kl√≠ƒç, ale ≈æ√°dn√© vl√°kno (parametr ?t=...). Link je ne√∫pln√Ω.");
      logShadow(shadowLang === "cs"
        ? "kl√≠ƒç m√°≈°, thread ne ¬∑ nƒõkdo se≈ô√≠zl URL."
        : "you have the key, but no thread ¬∑ someone cut the URL.");
      chatInput.disabled = true;
      chatSendBtn.disabled = true;
      return;
    }

    try {
      threadToken = token;
      threadKeyB64 = keyStr;
      threadKey = await importThreadKey(keyStr);
      bumpActivity();

      setThreadInfo("Vl√°kno z URL. ƒåtu ≈°ifrovan√Ω thread...");
      chatInput.disabled = false;
      chatSendBtn.disabled = false;
      logShadow(shadowLang === "cs"
        ? "kl√≠ƒç sed√≠ ¬∑ poslouch√°m ve tmƒõ."
        : "key imported ¬∑ listening in the dark.");

      await loadThread();
      setInterval(loadThread, 5000);
    } catch (e) {
      console.error("initFromUrl error", e);
      setThreadInfo("Kl√≠ƒç ne≈°el importovat. Link je po≈°kozen√Ω.");
      logShadow(shadowLang === "cs"
        ? "kl√≠ƒç je rozbit√Ω ¬∑ nƒõkdo mu ubl√≠≈æil po cestƒõ."
        : "key import failed ¬∑ someone mangled the hash.");
      chatInput.disabled = true;
      chatSendBtn.disabled = true;
    }
  }

  function showShadow(force = false) {
    if (!shadowCard) return;
    if (force) {
      shadowCard.classList.remove("hidden");
      shadowStateLabel.textContent = "[open]";
      return;
    }
    if (Math.random() < 0.5) {
      shadowCard.classList.remove("hidden");
      shadowStateLabel.textContent = "[open]";
    }
  }

  function hideShadowRandomly() {
    if (!shadowCard) return;
    const diff = Date.now() - lastActivity;
    if (diff > 30000 && Math.random() < 0.35) {
      shadowCard.classList.add("hidden");
      shadowStateLabel.textContent = "[hidden]";
    }
  }

  function setupShadowIdleWatcher() {
    setInterval(() => {
      const diff = Date.now() - lastActivity;

      if (diff > shadowConfig.idleFirst &&
          shadowConfig.lastIdleNoticed < shadowConfig.idleFirst) {
        shadowConfig.lastIdleNoticed = shadowConfig.idleFirst;
        const txt = pick(shadowTexts[shadowLang].idle);
        logShadow(txt);
      }

      if (diff > shadowConfig.idleSecond &&
          shadowConfig.lastIdleNoticed < shadowConfig.idleSecond) {
        shadowConfig.lastIdleNoticed = shadowConfig.idleSecond;
        const txt = pick(shadowTexts[shadowLang].longIdle);
        logShadow(txt);
      }

      hideShadowRandomly();
    }, 10000);
  }

  function setupShadowHeckler() {
    setInterval(() => {
      const diff = Date.now() - lastActivity;
      if (diff < 15000) return;
      if (Math.random() < 0.35) {
        const txt = pick(shadowTexts[shadowLang].random);
        logShadow(txt);
      }
    }, shadowConfig.heckleEveryMin);
  }

  function setupShadowHover() {
    if (!shadowCard) return;
    shadowCard.addEventListener("mouseenter", () => {
      bumpActivity();
      // lehk√© ‚Äûbrnƒõn√≠‚Äú
      if (Math.random() < 0.5) {
        shadowCard.classList.add("glitch");
        setTimeout(() => shadowCard.classList.remove("glitch"), 180);
      }
    });
  }

  async function handleLangSwitch() {
    const prev = shadowLang;
    const next = prev === "cs" ? "en" : "cs";

    if (prev === "en" && next === "cs") {
      logShadow('So you want Czech now? Cute. "We totally don\'t speak English."');
      logShadow("Sure, let me reboot into your comfort language so you can overthink properly.");
      shadowCard.classList.add("hidden");
      setTimeout(() => {
        shadowLang = "cs";
        if (shadowLangToggle) shadowLangToggle.textContent = "CZ";
        if (shadowLog) shadowLog.innerHTML = "";
        shadowCard.classList.remove("hidden");
        shadowStateLabel.textContent = "[open]";
        logShadow("Restart do ƒçe≈°tiny hotov√Ω. Spokojen√Ω, nebo je≈°tƒõ reset ega?");
      }, 900);
    } else if (prev === "cs" && next === "en") {
      logShadow("A m√°me tu chytr√°ka v angliƒçtinƒõ. To jsou mi vƒõci.");
      logShadow("Switching to English so your inner monologue can sound smarter than it is.");
      shadowCard.classList.add("hidden");
      setTimeout(() => {
        shadowLang = "en";
        if (shadowLangToggle) shadowLangToggle.textContent = "EN";
        if (shadowLog) shadowLog.innerHTML = "";
        shadowCard.classList.remove("hidden");
        shadowStateLabel.textContent = "[open]";
        logShadow("Reboot complete. Language upgraded, judgment unchanged.");
      }, 900);
    } else {
      shadowLang = next;
      if (shadowLangToggle) shadowLangToggle.textContent = next === "cs" ? "CZ" : "EN";
    }
  }

  function setupLangToggle() {
    if (!shadowLangToggle) return;
    shadowLangToggle.addEventListener("click", (e) => {
      e.stopPropagation();
      handleLangSwitch();
    });
  }

  // Console input m√≥d ‚Äì psan√≠ p≈ô√≠mo konzoli
  let consoleInputRow = null;
  let consoleInputEl = null;

  function toggleConsoleInput() {
    if (!shadowLog) return;
    if (!consoleInputRow) {
      consoleInputRow = document.createElement("div");
      consoleInputRow.style.marginTop = "6px";
      consoleInputRow.style.display = "flex";
      consoleInputRow.style.gap = "6px";

      consoleInputEl = document.createElement("input");
      consoleInputEl.type = "text";
      consoleInputEl.placeholder = "napi≈° / type to console‚Ä¶";
      consoleInputEl.style.flex = "1";
      consoleInputEl.style.borderRadius = "999px";
      consoleInputEl.style.border = "1px solid #3b3558";
      consoleInputEl.style.background = "#05020f";
      consoleInputEl.style.color = "#f4f3ff";
      consoleInputEl.style.fontSize = "0.75rem";
      consoleInputEl.style.padding = "4px 8px";

      const btn = document.createElement("button");
      btn.textContent = "‚Üí";
      btn.style.borderRadius = "999px";
      btn.style.border = "1px solid #5df2ff";
      btn.style.background = "transparent";
      btn.style.color = "#eaffff";
      btn.style.fontSize = "0.7rem";
      btn.style.cursor = "pointer";
      btn.style.padding = "3px 8px";

      btn.addEventListener("click", () => {
        handleConsoleMessage();
      });
      consoleInputEl.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          handleConsoleMessage();
        }
      });

      consoleInputRow.appendChild(consoleInputEl);
      consoleInputRow.appendChild(btn);
      shadowLog.appendChild(consoleInputRow);
    } else {
      const visible = consoleInputRow.style.display !== "none";
      consoleInputRow.style.display = visible ? "none" : "flex";
    }
    if (consoleInputRow && consoleInputRow.style.display !== "none" && consoleInputEl) {
      consoleInputEl.focus();
    }
  }

  function handleConsoleMessage() {
    if (!consoleInputEl) return;
    const text = (consoleInputEl.value || "").trim();
    if (!text) return;
    consoleInputEl.value = "";
    bumpActivity();

    const ts = new Date().toLocaleTimeString("cs-CZ", { hour: "2-digit", minute: "2-digit" });
    const userLine = document.createElement("div");
    userLine.className = "shadow-line";
    userLine.innerHTML = `<span>[you]</span> ${text}`;
    shadowLog.appendChild(userLine);
    shadowLog.scrollTop = shadowLog.scrollHeight;

    const reply = pick(shadowTexts[shadowLang].consoleReply);
    logShadow(reply);
  }

  function setupConsoleInput() {
    if (!shadowLog) return;
    // double-click do logu obƒças pust√≠ input (random gate)
    shadowLog.addEventListener("dblclick", () => {
      if (Math.random() < 0.4) {
        const msg = shadowLang === "cs"
          ? "dob≈ôe, v√Ωjimeƒçnƒõ m≈Ø≈æe≈° mluvit p≈ô√≠mo ke mnƒõ."
          : "fine, I‚Äôll let you talk to the console directly this time.";
        logShadow(msg);
        toggleConsoleInput();
      } else {
        const msg = shadowLang === "cs"
          ? "teƒè zrovna ne. zkus to, a≈æ bude≈° m√≠≈à zoufal√Ω."
          : "not in the mood. try again when you‚Äôre less desperate.";
        logShadow(msg);
      }
    });
  }

  function setupShadowToggle() {
    if (!shadowCard || !shadowTitle || !shadowStateLabel) return;

    // kliknut√≠ na header ‚Üí teleport ≈°mejd
    shadowTitle.addEventListener("click", (e) => {
      maybeTeleport();
    });

    shadowCard.addEventListener("click", (e) => {
      if (e.target === shadowLangToggle) return;
      if (!shadowTitle.contains(e.target) && Math.random() < 0.25) {
        maybeTeleport();
      }
    });
  }

  document.addEventListener("DOMContentLoaded", () => {
    applyShadowPos(currentShadowPosIndex);

    if (createThreadBtn) {
      createThreadBtn.addEventListener("click", () => {
        createThread();
      });
    }
    if (chatSendBtn) {
      chatSendBtn.addEventListener("click", () => {
        sendMessage();
      });
    }
    if (chatInput) {
      chatInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          sendMessage();
        }
      });
    }

    if (shadowCard && shadowStateLabel) {
      shadowStateLabel.textContent = "[open]";
    }

    setupShadowToggle();
    setupLangToggle();
    setupShadowIdleWatcher();
    setupShadowHeckler();
    setupShadowHover();
    setupConsoleInput();
    initFromUrl();
  });
</script>